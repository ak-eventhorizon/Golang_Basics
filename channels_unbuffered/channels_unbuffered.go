package main // определение пакета для текущего файла
import (
	"fmt"
)

// ********* Channels Unbuffered *********
// Для создания небуферизированного канала вызывается функция make() без указания емкости канала.

// Если канал пустой, то горутина-получатель блокируется, пока в канале не окажутся данные.
// Горутина-отправитель может отправлять данные только в пустой канал. Горутина-отправитель блокируется до тех пор, пока данные из канала не будут получены.

func main() {

	intCh := make(chan int) // создание и инициализация небуферизированного канала

	// *********************************************************************************************************************
	// если горутина определена в виде анонимной функции - она имеет доступ к окружению, в том числе к переменной intCh
	go func() {
		fmt.Println("Gorutine starts")
		fmt.Println("Gorutine send 5 to channel")
		intCh <- 5 // блокировка горутины, пока данные не будут получены функцией main в 29 строке
		fmt.Println("Gorutine send 6 to channel")
		intCh <- 6 // блокировка горутины, пока данные не будут получены функцией main в 32 строке
		fmt.Println("Gorutine finished")
	}()

	fmt.Scanln() // пауза 1

	fmt.Println("Main takes value", <-intCh) // получение из канала значения 5
	fmt.Scanln()                             // пауза 2

	fmt.Println("Main takes value", <-intCh) // получение из канала значения 6
	fmt.Scanln()                             // пауза 3

	// *********************************************************************************************************************
	// если горутина определена в виде обычной функции - то объекты каналов надо передавать ей через параметры
	go factorial(5, intCh)
	fmt.Println("Factorial =", <-intCh)

}

func factorial(n int, ch chan int) {

	result := 1
	for i := 1; i <= n; i++ {
		result *= i
	}

	ch <- result // отправка данных в канал
}
